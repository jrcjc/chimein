/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.18_02 from the
 * contents of Cmds.xs. Do not edit this file, edit Cmds.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Cmds.xs"
#include "module.h"
#include "../perl-handlers.h"

#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#line 18 "Cmds.c"

XS(XS_Purple__Cmd_help); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cmd_help)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Purple::Cmd::help", "conv, command");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Purple__Conversation	conv = purple_perl_ref_object(ST(0));
	const gchar *	command = (const gchar *)SvPV_nolen(ST(1));
#line 69 "Cmds.xs"
	GList *l, *ll;
#line 38 "Cmds.c"
#line 71 "Cmds.xs"
	for (l = ll = purple_cmd_help(conv, command); l != NULL; l = l->next) {
		XPUSHs(sv_2mortal(newSVpv(l->data, 0)));
	}
	g_list_free(ll);
#line 44 "Cmds.c"
	PUTBACK;
	return;
    }
}


XS(XS_Purple__Cmd_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cmd_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Purple::Cmd::list", "conv");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Purple__Conversation	conv = purple_perl_ref_object(ST(0));
#line 80 "Cmds.xs"
	GList *l, *ll;
#line 68 "Cmds.c"
#line 82 "Cmds.xs"
	for (l = ll = purple_cmd_list(conv); l != NULL; l = l->next) {
		XPUSHs(sv_2mortal(newSVpv(l->data, 0)));
	}
	g_list_free(ll);
#line 74 "Cmds.c"
	PUTBACK;
	return;
    }
}


XS(XS_Purple__Cmd_register); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cmd_register)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 8 || items > 9)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Purple::Cmd::register", "plugin, command, args, priority, flag, prpl_id, func, helpstr, data = 0");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Purple__Plugin	plugin = purple_perl_ref_object(ST(0));
	const gchar *	command = (const gchar *)SvPV_nolen(ST(1));
	const gchar *	args = (const gchar *)SvPV_nolen(ST(2));
	Purple__Cmd__Priority	priority = (Purple__Cmd__Priority)SvIV(ST(3));
	Purple__Cmd__Flag	flag = (Purple__Cmd__Flag)SvIV(ST(4));
	const gchar *	prpl_id = (const gchar *)SvPV_nolen(ST(5));
	SV *	func = ST(6);
	const gchar *	helpstr = (const gchar *)SvPV_nolen(ST(7));
	SV *	data;
	Purple__Cmd__Id	RETVAL;
	dXSTARG;

	if (items < 9)
	    data = 0;
	else {
	    data = ST(8);
	}
#line 99 "Cmds.xs"
	RETVAL = purple_perl_cmd_register(plugin, command, args, priority, flag,
	                                prpl_id, func, helpstr, data);
#line 113 "Cmds.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Purple__Cmd_unregister); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cmd_unregister)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Purple::Cmd::unregister", "id");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	Purple__Cmd__Id	id = (Purple__Cmd__Id)SvIV(ST(0));
#line 108 "Cmds.xs"
	purple_perl_cmd_unregister(id);
#line 135 "Cmds.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Purple__Cmd); /* prototype to pass -Wmissing-prototypes */
XS(boot_Purple__Cmd)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXSproto("Purple::Cmd::help", XS_Purple__Cmd_help, file, "$$");
        newXSproto("Purple::Cmd::list", XS_Purple__Cmd_list, file, "$");
        newXSproto("Purple::Cmd::register", XS_Purple__Cmd_register, file, "$$$$$$$$;$");
        newXSproto("Purple::Cmd::unregister", XS_Purple__Cmd_unregister, file, "$");

    /* Initialisation Section */

#line 8 "Cmds.xs"
{
	HV *status_stash = gv_stashpv("Purple::Cmd::Status", 1);
	HV *ret_stash = gv_stashpv("Purple::Cmd::Return", 1);
	HV *p_stash = gv_stashpv("Purple::Cmd::Priority", 1);
	HV *flag_stash = gv_stashpv("Purple::Cmd::Flag", 1);

	static const constiv *civ, status_const_iv[] = {
#define const_iv(name) {#name, (IV)PURPLE_CMD_STATUS_##name}
		const_iv(OK),
		const_iv(FAILED),
		const_iv(NOT_FOUND),
		const_iv(WRONG_ARGS),
		const_iv(WRONG_PRPL),
		const_iv(WRONG_TYPE),
	};
	static const constiv ret_const_iv[] = {
#undef const_iv
#define const_iv(name) {#name, (IV)PURPLE_CMD_RET_##name}
		const_iv(OK),
		const_iv(FAILED),
		const_iv(CONTINUE),
	};
	static const constiv p_const_iv[] = {
#undef const_iv
#define const_iv(name) {#name, (IV)PURPLE_CMD_P_##name}
		const_iv(VERY_LOW),
		const_iv(LOW),
		const_iv(DEFAULT),
		const_iv(PRPL),
		const_iv(PLUGIN),
		const_iv(ALIAS),
		const_iv(HIGH),
		const_iv(VERY_HIGH),
	};
	static const constiv flag_const_iv[] = {
#undef const_iv
#define const_iv(name) {#name, (IV)PURPLE_CMD_FLAG_##name}
		const_iv(IM),
		const_iv(CHAT),
		const_iv(PRPL_ONLY),
		const_iv(ALLOW_WRONG_ARGS),
	};

	for (civ = status_const_iv + sizeof(status_const_iv) / sizeof(status_const_iv[0]); civ-- > status_const_iv;)
		newCONSTSUB(status_stash, (char *)civ->name, newSViv(civ->iv));

	for (civ = ret_const_iv + sizeof(ret_const_iv) / sizeof(ret_const_iv[0]); civ-- > ret_const_iv;)
		newCONSTSUB(ret_stash, (char *)civ->name, newSViv(civ->iv));

	for (civ = p_const_iv + sizeof(p_const_iv) / sizeof(p_const_iv[0]); civ-- > p_const_iv;)
		newCONSTSUB(p_stash, (char *)civ->name, newSViv(civ->iv));

	for (civ = flag_const_iv + sizeof(flag_const_iv) / sizeof(flag_const_iv[0]); civ-- > flag_const_iv;)
		newCONSTSUB(flag_stash, (char *)civ->name, newSViv(civ->iv));
}

#line 221 "Cmds.c"

    /* End of Initialisation Section */

    if (PL_unitcheckav)
         call_list(PL_scopestack_ix, PL_unitcheckav);
    XSRETURN_YES;
}

